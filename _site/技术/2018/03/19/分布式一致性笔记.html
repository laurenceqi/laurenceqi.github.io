<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      分布式一致性笔记 &middot; Laurence
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/favicon.ico">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Laurence
        </a>
      </h1>
      <p class="lead">读书、思考</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about.html">About</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/categories.html">Categories</a>
          
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/tags.html">Tags</a>
          
        
      

    </nav>

    <p>&copy; 2018. laurence 版权所有.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">分布式一致性笔记</h1>
  <span class="post-date">19 Mar 2018</span>
  <h2 id="什么是分布式一致性">什么是分布式一致性？</h2>
<p>分布式一致性是指Atomic Consistent, Every read receives the most recent write or an error。指的是请求之间的数据一致性。</p>

<blockquote>
  <p>The CAP theorem is based on three trade-offs, one of which is “atomic consistency” (shortened to “consistency” for the acronym), about which the authors note, “Discussing atomic consistency is somewhat different than talking about an ACID database, as database consistency refers to transactions, while atomic consistency refers only to a property of a single request/response operation sequence. And it has a different meaning than the Atomic in ACID, as it subsumes the database notions of both Atomic and Consistent.” <sup id="fnref:consistent"><a href="#fn:consistent" class="footnote">1</a></sup></p>
</blockquote>

<p>与ACID中的C的意义并不相同。 ACID中的一致性指的是事务中的对数据的修改是一致的，没有违反相关的规则和约束，完成了完整的状态变迁。</p>

<blockquote>
  <p>The consistency property ensures that any transaction will bring the database from one valid state to another. Any data written to the database must be valid according to all defined rules, including constraints, cascades, triggers, and any combination thereof. This does not guarantee correctness of the transaction in all ways the application programmer might have wanted (that is the responsibility of application-level code), but merely that any programming errors cannot result in the violation of any defined rules. <sup id="fnref:ACID"><a href="#fn:ACID" class="footnote">2</a></sup></p>
</blockquote>

<p>与内存的一致性模型也有区别，内存一致性是指不同的进程读写内存时对其他进程的可见性，具体模型可以查看wiki<sup id="fnref:Consistent_model"><a href="#fn:Consistent_model" class="footnote">3</a></sup> 。</p>

<p>分布式一致性归根到底是在分布式环境下数据的一致性，从实现方式上，可以大体分为三类，以以下具体例子来说明：</p>
<blockquote>
  <p>Assume that the following case occurs:</p>

  <p>The row X is replicated on nodes M and N<br />
The client A writes row X to node M<br />
After a period of time t, client B reads row X from node N</p>
</blockquote>

<blockquote>
  <p>The consistency model has to determine whether client B sees the write from client A or not.</p>
</blockquote>

<ol>
  <li>
    <p><strong>强一致性</strong><br />
 B马上可以读到X的正确值</p>
  </li>
  <li>
    <p><strong>弱一致性</strong><br />
B有可能读到X的正确值，有可能读不到</p>
  </li>
  <li>
    <p><strong>最终一致性</strong><br />
 经过 t 时间，B一定可以读到X的正确值</p>
  </li>
</ol>

<h2 id="为什么会存在分布式一致性">为什么会存在分布式一致性？</h2>

<h4 id="为什么数据要写多份">为什么数据要写多份</h4>
<ol>
  <li>单台机器会挂</li>
  <li>单台机器性能瓶颈</li>
  <li>架构使然，e.g. 微服务，领域划分</li>
</ol>

<h4 id="写多份为什么有一致性问题">写多份为什么有一致性问题</h4>
<ol>
  <li>节点异常 e.g. 机器挂了</li>
  <li>通信（网络）异常
    <ol>
      <li>消息丢失，e.g. 网络分区，网络设备故障</li>
      <li>消息乱序<br />
包级别的乱序可通过网络协议，如TCP解决；<br />
但消息与消息之间的全局顺序无法保证</li>
      <li>数据错误，可通过网络协议解决</li>
    </ol>
  </li>
  <li>服务异常
    <ol>
      <li>RPC的三态
        <ol>
          <li>成功</li>
          <li>失败</li>
          <li>超时（无法确定服务端处理状态）
            <ol>
              <li>客户端发送成功，服务端无响应</li>
              <li>服务端处理成功，未返回客户端</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>顺序问题<br />
当有多个客户端，多个服务端，多个存储时，全局的顺序无法保证。<br />
有可能网络拥堵，有可能进程处理缓慢，有可能硬件处理缓慢等。</li>
</ol>

<h2 id="理论">理论</h2>

<h4 id="cap定理">CAP定理<sup id="fnref:CAP"><a href="#fn:CAP" class="footnote">4</a></sup></h4>

<p><img src="/public/CAP.png" alt="" /></p>

<ul>
  <li><strong>Consistency</strong><br />
Every read receives the most recent write or an error</li>
  <li><strong>Availability</strong><br />
Every request receives a (non-error) response – without guarantee that it contains the most recent write</li>
  <li><strong>Partition tolerance</strong><br />
The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes</li>
</ul>

<p>CAP理论指出了C、A、P无法同时满足。<br />
当出现分区问题时，如果保证了可用性，是无法保证一致性的。因为网络分区的出现，部分节点是不可达的。如果忽略网络分区，一致性和可用性都是可以保证的。<br />
所以CAP理论更多时候，是在出现网络分区问题时，可用性和一致性的取舍问题。<br />
选择可用性，必然会导致部分节点无法达到一致；选择一致性，必然要选择部分节点不可提供服务。</p>

<h4 id="pacelc-定理">PACELC 定理<sup id="fnref:PACELC"><a href="#fn:PACELC" class="footnote">5</a></sup></h4>

<blockquote>
  <p>In theoretical computer science, the PACELC theorem is an extension to the CAP theorem. It states that in case of network partitioning (P) in a distributed computer system, one has to choose between availability (A) and consistency (C) (as per the CAP theorem), but else (E), even when the system is running normally in the absence of partitions, one has to choose between latency (L) and consistency (C).</p>
</blockquote>

<p>PACELC定理是CAP定理的延伸，是指在网络分区的情况下，需要在可用性和一致性之间做选择，否则，就在延迟和一致性之间做选择。</p>

<p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Transaction-Across-DataCenter.jpg" alt="" /><br />
上图来自：Google App Engine的co-founder Ryan Barrett在2009年的google i/o上的演讲《Transaction Across DataCenter》</p>

<h2 id="如何实现">如何实现？</h2>

<h4 id="从节点的组织形式上可以分成两类">从节点的组织形式上可以分成两类：</h4>

<ol>
  <li>中心化副本控制协议 <br />
通过中心化节点来控制副本的更新来达成一致 e.g. Master-Slave，raft</li>
  <li>去中心化副本控制协议<br />
各节点地位相同，通过平等协商的方式来达到一致 e.g. Paxos</li>
</ol>

<h4 id="lease机制">Lease机制<sup id="fnref:dis"><a href="#fn:dis" class="footnote">6</a></sup></h4>
<p>Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发 出 lease,则无论接受方是否收到,也无论后续接收方处于何种状态,只要 lease 不过期,颁发者一 定严守承诺;另一方面,接收方在 lease 的有效期内可以使用颁发者的承诺,但一旦 lease 过期,接收方一定不能继续使用颁发者的承诺。</p>

<p>由于 lease 是一种承诺,具体的承诺内容可以非常宽泛,可以是数据的正确性，如在lease有效期内不会修改数据;也可以是某种权限,例如当需要做并发控制时,同一时刻只给某一个节点颁发 lease,只有持有 lease 的节点才可以修改数据;也可以是某种身份,例如在 primary-secondary架构中,给节点颁发 lease,只有持有 lease 的节点才具有 primary 身份。</p>

<p>举例说明，GFS 中使用 Lease 确定 Chuck 的 Primary 副本。Lease 由 Master 节点颁发给 primary 副本,持有 Lease 的副本成为 primary 副本。Primary 副本控制该 chuck 的数据更新流量,确定并发更新操作在 chuck 上的执行顺序。GFS 中的 Lease 信息由 Master 在响应各个节点的 HeartBeat 时附带传递 (piggyback)。对于每一个 chuck,其上的并发更新操作的顺序在各个副本上是一致的,首先 master 选择 primary 的顺序,即颁发 Lease 的顺序,在每一任的 primary 任期内,每个 primary 决定并发更 新的顺序,从而更新操作的顺序最终全局一致。当 GFS 的 master 失去某个节点的 HeartBeat 时,只需待该节点上的 primary chuck 的 Lease 超时,就可以为这些 chuck 重新选择 primary 副本并颁发 lease。</p>

<h4 id="quorum机制">Quorum机制</h4>
<p>在 Quorum 机制下,当某次更新操作 wi 一旦在所有 N 个副本中的 W 个副本上都成功,则就称 该更新操作为“成功提交的更新操作”,称对应的数据为“成功提交的数据”。令 R&gt;N-W,由于更新 操作 wi 仅在 W 个副本上成功,所以在读取数据时,最多需要读取 R 个副本则一定能读到 wi 更新后 的数据 vi 。如果某次更新 wi 在 W 个副本上成功,由于 W+R&gt;N,任意 R 个副本组成的集合一定与 成功的W个副本组成的集合有交集,所以读取R个副本一定能读到wi更新后的数据vi。</p>

<p><img src="/public/qorum.png" alt="" /></p>

<p>举例说明：<br />
某系统有 5 个副本,W=3,R=3,最初 5 个副本的数据一致,都是 v1,某次更新操作 w2 在前 3 副本上成功,副本情况变成(v2 v2 v2 v1 v1)。此时,任意 3 个副本组成的集合中一定包括 v2。</p>

<p>限制 Quorum 参数为 W+R=N+1。由于更新 操作需要在 W 个副本上都成功,更新操作才能成功,所以一旦 N-W+1 个副本异常,更新操作始终 无法在 W 个副本上成功,更新服务不可用。另一方面,一旦 N-R+1 个副本异常,则无法保证一定 可以读到与 W 个副本有交集的副本集合,则读服务的一致性下降。</p>

<p>N=5,W=2,R=3 时,若 4 个副本异常,更新操作始终无法完成。若 3 个副本异常时, 剩下的两个副本虽然可以提供更新服务,但对于读取者而言,在缺乏某些 magic 机制的,即如果读 取者不知道当前最新已成功提交的版本是什么的时候,仅仅读取 2 个副本并不能保证一定可以读到最新的已提交的数据。</p>

<p>这里再次强调:<strong>仅仅依赖 quorum 机制是无法保证强一致性的</strong>。因为仅有 quorum 机制时无法确 定最新已成功提交的版本号,除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数据集群管理,否则很难确定最新成功提交的版本号。</p>

<h4 id="paxos">Paxos</h4>
<p>去中心化的强一致性协议，具体可以参考wiki <sup id="fnref:paxos"><a href="#fn:paxos" class="footnote">7</a></sup></p>

<h4 id="raft">Raft</h4>
<p>通过去中心化的leader选举转化成中心化控制的强一致性协议</p>

<h4 id="2pc3pc">2PC/3PC</h4>
<p>中心化的强一致性协议</p>

<h4 id="master-slave">Master-Slave</h4>
<p>中心化的协议，可以根据同步协议来达到不同的一致性级别。举例，mysql的主从同步可以是async、semi-sync、sync来平衡性能和一致性</p>

<h4 id="mq">MQ</h4>
<p>通过MQ,日志表等方式达到最终一致性</p>

<h2 id="引用">引用</h2>

<div class="footnotes">
  <ol>
    <li id="fn:consistent">
      <p>https://en.wikipedia.org/wiki/Consistency_(database_systems) <a href="#fnref:consistent" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:ACID">
      <p>https://en.wikipedia.org/wiki/ACID <a href="#fnref:ACID" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:Consistent_model">
      <p>https://en.wikipedia.org/wiki/Consistency_model <a href="#fnref:Consistent_model" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:CAP">
      <p>https://en.wikipedia.org/wiki/CAP_theorem <a href="#fnref:CAP" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:PACELC">
      <p>https://en.wikipedia.org/wiki/PACELC_theorem <a href="#fnref:PACELC" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:dis">
      <p>《分布式系统原理介绍》 刘杰 <a href="#fnref:dis" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:paxos">
      <p>https://en.wikipedia.org/wiki/Paxos_(computer_science) <a href="#fnref:paxos" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
this.page.url = "http://laurenceqi.me/%E6%8A%80%E6%9C%AF/2018/03/19/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AC%94%E8%AE%B0.html";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "/%E6%8A%80%E6%9C%AF/2018/03/19/分布式一致性笔记"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://laurenceqi.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            

    </div>

  </body>
</html>
