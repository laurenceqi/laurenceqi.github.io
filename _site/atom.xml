<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Laurence</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2018-03-22T20:11:15+08:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>你应该知道的Java内存模型（二）</title>
   <link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2018/03/22/JMM2.html"/>
   <updated>2018-03-22T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2018/03/22/JMM2</id>
   <content type="html">&lt;h2 id=&quot;什么是指令重排序&quot;&gt;什么是指令重排序？&lt;/h2&gt;
&lt;p&gt;第一篇文章已经讲了指令重排序的例子。&lt;br /&gt;
代码实际执行时，访问变量的指令可能会因为以下原因与代码顺序不符：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编译器为优化性能重排指令&lt;/li&gt;
  &lt;li&gt;处理器在特定情况下重排指令执行顺序&lt;/li&gt;
  &lt;li&gt;数据在寄存器、处理器缓存、内存之间的移动顺序&lt;/li&gt;
  &lt;li&gt;其他的一些原因，如JIT等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;指令重排，从单线程的角度来看，规范规定了不会影响输出结果。但如果一个变量被&lt;strong&gt;多个线程同时访问&lt;/strong&gt;，重排就会影响变量的一致性。&lt;br /&gt;
为了能够在多线程环境下正确的访问变量，因此需要&lt;strong&gt;正确&lt;/strong&gt;的Synchronization。&lt;/p&gt;

&lt;h2 id=&quot;什么叫做-不正确-的同步&quot;&gt;什么叫做 &lt;em&gt;不正确&lt;/em&gt; 的同步？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;一个线程写入一个变量&lt;/li&gt;
  &lt;li&gt;另外一个线程读取同一个变量&lt;/li&gt;
  &lt;li&gt;对这个变量的读写没有使用&lt;strong&gt;同步机制&lt;/strong&gt;来决定顺序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所有违反上述条件的都会产生竞态，是不正确的同步。&lt;/p&gt;

&lt;h2 id=&quot;同步机制是做什么的&quot;&gt;同步机制是做什么的？&lt;/h2&gt;

&lt;p&gt;同步主要有以下几种影响：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;互斥排他&lt;/strong&gt;&lt;br /&gt;
同时只能有一个线程获得Monitor。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内存可见性&lt;/strong&gt;&lt;br /&gt;
当一个线程释放同步锁的时候，会确保自己的写入对其他线程可见。可能是通过数据刷入内存、其他线程失效本地缓存等方式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;禁止重排序&lt;/strong&gt;&lt;br /&gt;
在同步锁的获取和释放前后的代码块，不会重排序。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新的Java内存模型在内存操作（读字段，写字段，lock，unlock）和线程操作（start，join）之间定义了顺序，叫做一种操作 &lt;strong&gt;happens before&lt;/strong&gt; 其他操作。当一种操作happens before另外一种操作时，第一个操作被确保在第二个操作之前执行，而且操作内容对第二个操作可见。具体规则如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;单线程里面每个操作 happens before 程序里面此操作后面的操作&lt;/li&gt;
  &lt;li&gt;对一个monitor的unlock操作 happens before 在&lt;strong&gt;这个monitor&lt;/strong&gt;上所有后续的lock操作&lt;/li&gt;
  &lt;li&gt;对一个volatile字段的写入 happens before 对&lt;strong&gt;这个字段&lt;/strong&gt;的所有后续读操作&lt;/li&gt;
  &lt;li&gt;对一个线程的start操作 happens before 此启动线程里面的任何操作&lt;/li&gt;
  &lt;li&gt;对一个线程使用join操作，被join线程里面的任何操作 happens before join() 调用的返回&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，如果对一个monitor进行同步，所有释放monitor前的操作都对后续获取monitor的线程可见。因为所有的内存操作 happens before 所释放， 锁释放 happens before 接下来的锁获取。&lt;/p&gt;

&lt;h2 id=&quot;final是怎么样工作的&quot;&gt;final是怎么样工作的？&lt;/h2&gt;
&lt;p&gt;只要对象是被 &lt;strong&gt;正确的构造&lt;/strong&gt; 的，只要这个对象构造完成，赋值给final字段的值即使没有同步机制，对其他所有的线程也是可见的。即使final字段是其他对象或数组的引用，这些引用值也至少跟final字段一样是 &lt;em&gt;up to date as of the end of the object’s constructor&lt;/em&gt; 。&lt;/p&gt;

&lt;p&gt;正确的构造的含义是指在构造过程中，该对象的引用没有泄露。具体可以参考链接 &lt;a href=&quot;https://www.ibm.com/developerworks/library/j-jtp0618/&quot;&gt;Safe Construction Techniques&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单举个没有正确构造的例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FinalFieldExample&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// bad!&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// bad construction - allowing this to escape&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;虽然说了这么多，但如果一个线程创建了一个不可变对象（所有字段都是final），你想让其他线程能够正确看到这个对象，&lt;strong&gt;你还是需要使用同步&lt;/strong&gt;。因为对这个对象的引用，如果你不使用同步机制，是无法保证被其他线程可见的。&lt;/p&gt;

&lt;h2 id=&quot;volatile是干什么的&quot;&gt;volatile是干什么的？&lt;/h2&gt;
&lt;p&gt;Volatile是用来线程间交换状态特殊关键字。每次volatile读都会读到其他任何线程上次写入的值。每次写入后，都会刷入内存。每次读取前，也会失效本地缓存，直接从内存读取。除此之外，还有特殊的限制，跟老的内存模型不同，新的内存模型不允许在volatile字段前后进行指令重排序。当线程A在写volatile字段f前所有可见的字段都会线程B读取f时可见。
举例：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VolatileExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//uses x - guaranteed to see 42.&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所以对volatile来说就是半个synchronized，在内存可见性方面保持一样，但不具有排他性。&lt;/p&gt;

&lt;h2 id=&quot;double-checked-locking&quot;&gt;double-checked locking&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// double-checked-locking - don't do this!&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Something&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Something&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Something&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上面的写法是有问题的，大家可以根据学到的知识进行分析一下，哪些地方存在问题？如何解决？有没有更好的单例写法？&lt;/p&gt;

&lt;h2 id=&quot;引用&quot;&gt;引用&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html&quot;&gt;JSR133 FAQ&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>你应该知道的Java内存模型（一）</title>
   <link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2018/03/21/JMM.html"/>
   <updated>2018-03-21T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2018/03/21/JMM</id>
   <content type="html">&lt;h2 id=&quot;什么是java内存模型&quot;&gt;什么是JAVA内存模型？&lt;/h2&gt;
&lt;p&gt;因为CPU处理的速度比内存读取的速度快很多，通过缓存可以极大的提升CPU处理速度。并且，多级缓存的设计，可以平衡缓存大小与芯片体积、成本，在现代CPU中广泛使用。在多核且多级缓存的条件下，如果多个核同时读写内存的同一行，如何保证数据的一致性？&lt;/p&gt;

&lt;p&gt;在处理器级别，内存模型定义了什么条件下该核能够看到其他核的写入和该核的写入能够对其他核可见。有以下两种模型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;强一致内存模型，即任何时间任何核的写入都对其他核可见&lt;/li&gt;
  &lt;li&gt;弱一致内存模型，即通过一些特殊的内存屏障指令（Memory Barrier)，来刷新内存或者失效本地核处理器缓存，来保证核间的可见性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在弱一致内存模型越来越流行，因为对一致性的弱化为CPU的性能优化提供了更大的空间。&lt;/p&gt;

&lt;p&gt;除了缓存的问题，编译器对&lt;strong&gt;代码的重排序&lt;/strong&gt;更加加重了一致性问题。只要没有改变程序的语义，编译器可以自由的调整代码的执行顺序，提前或延后代码的执行，所以对内存的写入也会提前或延后。在真正写入前，其他核是无法看到对内存所做的读写的。&lt;br /&gt;
&lt;strong&gt;这不是Bug，设计就是这样。&lt;/strong&gt;只要不违反内存模型的定义，编译器、运行时、硬件都可以自由的去调整执行顺序，来得到最优的性能。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reordering&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;如果读写在两个线程中并发执行，并且读到了r1=2，那么，r2=1吗？&lt;br /&gt;
&lt;strong&gt;不一定&lt;/strong&gt;，写线程可能做了代码重排序，如果执行顺序如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写线程写y=2&lt;/li&gt;
  &lt;li&gt;读线程读y=2，x=0&lt;/li&gt;
  &lt;li&gt;写线程写x=1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;程序的执行结果是r1=2， r2=0&lt;/p&gt;

&lt;p&gt;最后，引出我们问题的答案，JAVA内存模型定义了在多线程环境下什么样的行为是合法的，并且线程间是如何跟内存交互的。他描述了代码变量跟内存、寄存器处理这些变量的底层实现之前的关系。通过JAVA内存模型的定义，提供了一种使用多种硬件、多种编译器等优化方法仍然能正确运行代码的约定。&lt;/p&gt;

&lt;p&gt;Java包含多个关键词volatile，final，synchronized，用来帮助程序员描述并发语义。JAVA内存模型定义了volatile和synchronized的行为，并且确保正确同步的代码在所有的处理器架构上都能正确执行。&lt;/p&gt;

&lt;h2 id=&quot;为什么其他语言没有如c&quot;&gt;为什么其他语言没有，如C++？&lt;/h2&gt;
&lt;p&gt;其他的大部分语言，如C或C++，并没有对多线程提供直接的支持。在多种处理器架构、多种编译器下，多线程的正确执行严重依赖所使用的多线程类库，编译器和程序运行的硬件平台。&lt;/p&gt;

&lt;h2 id=&quot;内存模型的历史&quot;&gt;内存模型的历史&lt;/h2&gt;

&lt;p&gt;原来JAVA语言规范里面定义了一个老版本的Java内存模型，但是慢慢发现了很多缺陷，比如volatile的定义。
随后又制定了现行的JAVA内存模型，即JSR133，提供了一系列内存模型正式的语义。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>《原则》读书笔记</title>
   <link href="http://localhost:4000/%E8%AF%BB%E4%B9%A6/2018/03/20/%E5%8E%9F%E5%88%99-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
   <updated>2018-03-20T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E8%AF%BB%E4%B9%A6/2018/03/20/《原则》读书笔记</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.amazon.cn/dp/B078FFX8B6&quot;&gt;书籍链接–原则&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;书摘思考&quot;&gt;书摘&amp;amp;思考&lt;/h2&gt;

&lt;p&gt;书中的工作原则、生活原则已经有人做了整理，链接见下。&lt;br /&gt;
&lt;a href=&quot;https://mubu.com/doc/explore/12400&quot;&gt;生活、工作原则整理 From 幕布&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;做到头脑极度开放、极度透明&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于他人的观点，应该保持开放，放弃自己情绪化的一面。只有追求真相、正确的答案（无论来自于谁），对自我进化才是最有效率的&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;从更高的层次俯视机器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/public/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;客观面对现实，关注目标，寻找GAP，根据直接结果、后续结果和再后续的结果做决策，管理痛苦，从自己身上找原因。形成闭环，不断进化&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;五步流程法&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;有明确的目标。&lt;/li&gt;
    &lt;li&gt;找到阻碍你实现这些目标的问题，并且不容忍问题。&lt;br /&gt;
3.准确诊断问题，找到问题的根源。&lt;br /&gt;
4.规划可以解决问题的方案。&lt;br /&gt;
5.做一切必要的事来践行这些方案，实现成果。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;各步要独立完成，定目标，找GAP，找原因，想方案，Do！&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;影响大多数人实现人生愿望的两大障碍，自我意识和思维盲点。&lt;br /&gt;
自我意识指潜意识里的防卫机制，他是你难以接受自己的错误和缺点。&lt;/p&gt;

  &lt;p&gt;坚持友善地训练“较低层次的你”，以养成好的习惯。我过去一直以为，较高层次的自我需要和较低层次的自我斗争，夺取控制权，但我逐渐明白，更有效的做法是训练潜意识的、情绪性的自我，就像教育儿童听话一样。你需要坚持慈爱友善地训练它，以让自己养成好习惯。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;快慢思考，与潜意识做斗争，始终做出理性的决策。建立系统思维模型，正视思维盲点。&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;要认识到：（1）影响好决策的最大威胁是有害的情绪；（2）决策是一个两步流程（先了解后决定）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.谨记任何问题都存在很多层次。2.针对一个问题，明白你分析的是哪个层次。3.有意识地在不同层次之间转换，而不是把问题视为一堆没有内在区别、可以随意考察的事实。4.以下页图为模板把你的思考过程画成图。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/public/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;问题存在很多层次，避免只见树木不见森林，系统分析方法。决策也在合适的层次做出。&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;在“生活原则”部分，我阐释了帮助我做到以上两点的一些原则。我相信，因为类似的情况反复发生，所以拥有一些以深思熟虑为基础的原则，你将能应对在现实中遇到的几乎任何事情。你从哪里获得这些原则并不重要，拥有原则、持之以恒地运用原则、不断改进完善原则才最重要。为了得到有效的原则，拥抱现实并妥善应对现实至关重要。不要落入常见的陷阱，期盼现实与真实情况不同，或者你所处的现实与众不同。相反，你要拥抱现实，有效应对现实。毕竟，生活的真谛就是从你所处的现实中汲取出最大的价值。这需要你保持思想的透明，头脑开放地接受其他人的反馈。这将让你学到的东西大大增多。一路上你肯定会经历痛苦的失败。你需要认识到，失败既能化为动力，驱动你的个人进化，也能毁掉你，这取决于你如何应对失败。我相信进化是宇宙间最伟大的力量，我们都在以大致相同的方式进化。从概念上看，进化就像一系列反馈环，可能一直向上持续改善，可能保持水平，也可能持续下降直至毁灭。你的反馈环是什么样子，将由你自己决定。可以把进化进程描述为一个实现你愿望的五步流程，包括设定目标，找到问题并且不容忍问题，诊断问题，规划可以解决问题的方案，最后执行方案要求的各项任务。需要谨记的是，没有人能把每一步都做好，可以依靠其他人的帮助。拥有不同能力的人通力合作，可以创造出最强大的机器来实现目标。如果你愿意直面现实，接受直面现实带来的痛苦，遵循五步流程来驱动自己朝着目标前进，你就走上了成功之路。但大多数人做不到，因为他们固守自己的错误观点。这很容易解决：从自我中跳出来客观地俯视所处形势，权衡自己和其他人对形势的看法。因此，我认为你必须做到头脑极度开放。&lt;/p&gt;

  &lt;p&gt;阻碍我们做好这一点的最大障碍是自我意识障碍和思维盲点障碍。自我意识障碍是指我们天生希望拥有能力，并希望其他人这么看我们。思维盲点障碍是我们通过自己的主观角度看事物造成的。这两个障碍都会阻碍我们看到事实真相。最重要的解药是头脑极度开放：人抱着一种真诚的担忧，担心自己可能看不到最好的决策方式，从而以极度开放的心态看待问题。这是一种有效探索不同观点和可能性、不受自我意识和思维盲点阻碍的能力。做好这一点需要你奉行深思熟虑的意见分歧，即向与你意见不同的聪明人请教，以通过他们的视角看问题，形成更深刻的理解。这样做将提升你做出良好决策的概率，并给你极好的教益。如果你能学会头脑极度开放，奉行深思熟虑的意见分歧，你学到的东西将大大增多。最后，做到头脑极度开放需要你对自身与其他人的长处和短处有准确的评估。所以，了解一些关于大脑构造的知识，以及有助于你发现自身思维方式的各种心理测试，都是有益的。为了在其他人的帮助下做到最好，你必须理解人与人大不相同。简而言之，学习如何以最好的方式决策，并拥有勇气做出最好的决定，需要你：（1）追求你想要的东西；（2）通过头脑极度开放从失败中汲取良好的教益；（3）不断改变和进化，使自己能力更强，勇气更盛。在该部分的最后一条“学习如何有效决策”里，我分享了一些更具体的原则，帮助你做到上述的一切，并在特定环境中合理权衡各种选项，决定正确的道路。所有这些你当然都可以一个人做，但假如你对头脑极度开放这一概念稍有理解的话，你应当能清晰地看到，单打独斗能实现的成果有限。我们都需要其他人帮助我们斟酌，找到最好的决策，并帮助我们客观看待自身弱点，弥补短板。此外最重要的是，你周围的人，你与他们的互动方式，都会影响到你的生活。与目标一致的人合作，你实现目标的能力会比一个人干强得多。不过我们迄今还未探讨团队如何以最高的效率运作。这将是“工作原则”部分要探讨的内容。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;以上是生活原则的总结&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个机构就像一部机器，主要由两组部件构成：文化和人&lt;br /&gt;
a.优秀的机构拥有优秀的人和优秀的文化。&lt;br /&gt;
b.优秀的人具备高尚的品格和出色的能力。&lt;br /&gt;
c.优秀的文化不掩盖问题和分歧，而是公开妥善解决，喜欢让想象力驰骋且愿意开创先河。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/public/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ray把一切都理解为机器，输入、输出，不断去理解、调整机器的运作，最终将机器的输出与目标无限接近。从这个角度上，他把公司分解成文化和人，通过文化形成管理的风格，通过文化影响到每个人，形成一致的行为和价值观。&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;●严厉之爱有助于成就优异的工作业绩和建立良好的人际关系&lt;br /&gt;
a.为了成就伟大事业，对不应妥协的事情就必须坚持立场、寸步不让。&lt;br /&gt;
●基于可信度加权的创意择优是实现有效决策的最佳模式&lt;br /&gt;
●让热情与工作合二为一，并与志同道合者倾力推进&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;严厉的爱也就是基于事实出发，高绩效要求，对团队的每个人都是好事。个体得到成长，团队得到进化。&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;比做什么事更重要的是找对做事的人&lt;br /&gt;
7.1你最重要的决策是选好工作的责任人&lt;br /&gt;
a.最重要的责任人是在最高层负责订立目标、规划成果和组织实施的人。&lt;br /&gt;
7.2负最终责任的人应是对行为后果承担责任的人&lt;br /&gt;
a.确保每个人都有上级领导。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;找对人的人做事比做事重要！&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;基于可信度加权的创意择优是实现有效决策的最佳模式&lt;/p&gt;

  &lt;p&gt;创意择优=极度求真+极度透明+可信度加权的决策&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ray介绍了一种决策方式，基于可信度加权的决策模式。即如果这个人从历史的表现上在这个领域是可信的，那他决策的权重就要高！&lt;br /&gt;
非常有意思，据说知乎的推荐机制也是这样的，基于该领域大V的推荐权重来给用户推荐内容。与头条、微博等协同过滤的推荐算法是不是更高一层？&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果一个人工作干得不怎么样，要考虑这是由于学习不够，还是能力不足。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/public/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一件事情没有做，是不知道要做还是知道了没做，是两件事情。
如果一个人不能胜任工作，同样。&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;运用工具和行为准则指导工作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过准则来指导工作，在大家中形成共识和一致的行为模式。&lt;br /&gt;
这也是我在团队管理中正在使用的非常有效的方法。&lt;br /&gt;
很多人工作没做好，是没有意识到正确的做法是什么。当形成准则时，大家拥有了意识，如果没有做就是执行的问题。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/public/7.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/public/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;桥水成功的模式可以归纳成一下几点&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;独立思考，系统思考，基于逻辑、理性、常识来做分析、决策&lt;/li&gt;
  &lt;li&gt;创意择优=极度求真+极度透明+可信度加权的决策&lt;/li&gt;
  &lt;li&gt;形成原则&lt;/li&gt;
  &lt;li&gt;反馈闭环，持续改进&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;收获&quot;&gt;收获&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;进化方法论&lt;/strong&gt;&lt;br /&gt;
从达尔文的进化论，通过自然选择，优胜劣汰的持续作用，生物界进化到了现在的高级阶段。自然的进化，是个被动过程。但对人类来说，可以主动设计进化。反馈闭环，持续改进，对个人，对组织，对社会，各个方面均可应用。Ray就是自己设计进化的例子。他把人、机构都理解为一部机器，基于“&lt;em&gt;绝对&lt;/em&gt;”的客观事实，设计流程、机制，完成反馈闭环，持续进化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;极度求真&lt;/strong&gt;&lt;br /&gt;
人天生就有弱点，有潜意识的自我防守，有思维盲区，有自我利益服务的天生人性。如何克服，在个人、在组织中，形成一种追求“&lt;em&gt;绝对&lt;/em&gt;”事实，“&lt;em&gt;绝对&lt;/em&gt;”真理的机制？ Ray给大家上了一课，极度求真在现实中某种程度上是可行的。只有战胜低层次的自我，保持理性，求实且直面惨淡的事实，从此出发，制定目标、寻找GAP、制定措施、实施、达成，才能达到自我进化、组织进化的最高效率。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;可信度加权&lt;/strong&gt;&lt;br /&gt;
一种非常高效、可信的决策方法，这何尝不是一种信息筛选方法。基于此，做一套信息推荐系统，信息的可信度、专业性会非常高。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>分布式一致性笔记</title>
   <link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2018/03/19/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AC%94%E8%AE%B0.html"/>
   <updated>2018-03-19T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2018/03/19/分布式一致性笔记</id>
   <content type="html">&lt;h2 id=&quot;什么是分布式一致性&quot;&gt;什么是分布式一致性？&lt;/h2&gt;
&lt;p&gt;分布式一致性是指Atomic Consistent, Every read receives the most recent write or an error。指的是请求之间的数据一致性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The CAP theorem is based on three trade-offs, one of which is “atomic consistency” (shortened to “consistency” for the acronym), about which the authors note, “Discussing atomic consistency is somewhat different than talking about an ACID database, as database consistency refers to transactions, while atomic consistency refers only to a property of a single request/response operation sequence. And it has a different meaning than the Atomic in ACID, as it subsumes the database notions of both Atomic and Consistent.” &lt;sup id=&quot;fnref:consistent&quot;&gt;&lt;a href=&quot;#fn:consistent&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与ACID中的C的意义并不相同。 ACID中的一致性指的是事务中的对数据的修改是一致的，没有违反相关的规则和约束，完成了完整的状态变迁。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The consistency property ensures that any transaction will bring the database from one valid state to another. Any data written to the database must be valid according to all defined rules, including constraints, cascades, triggers, and any combination thereof. This does not guarantee correctness of the transaction in all ways the application programmer might have wanted (that is the responsibility of application-level code), but merely that any programming errors cannot result in the violation of any defined rules. &lt;sup id=&quot;fnref:ACID&quot;&gt;&lt;a href=&quot;#fn:ACID&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与内存的一致性模型也有区别，内存一致性是指不同的进程读写内存时对其他进程的可见性，具体模型可以查看wiki&lt;sup id=&quot;fnref:Consistent_model&quot;&gt;&lt;a href=&quot;#fn:Consistent_model&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; 。&lt;/p&gt;

&lt;p&gt;分布式一致性归根到底是在分布式环境下数据的一致性，从实现方式上，可以大体分为三类，以以下具体例子来说明：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Assume that the following case occurs:&lt;/p&gt;

  &lt;p&gt;The row X is replicated on nodes M and N&lt;br /&gt;
The client A writes row X to node M&lt;br /&gt;
After a period of time t, client B reads row X from node N&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The consistency model has to determine whether client B sees the write from client A or not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;强一致性&lt;/strong&gt;&lt;br /&gt;
 B马上可以读到X的正确值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;弱一致性&lt;/strong&gt;&lt;br /&gt;
B有可能读到X的正确值，有可能读不到&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;最终一致性&lt;/strong&gt;&lt;br /&gt;
 经过 t 时间，B一定可以读到X的正确值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;为什么会存在分布式一致性&quot;&gt;为什么会存在分布式一致性？&lt;/h2&gt;

&lt;h4 id=&quot;为什么数据要写多份&quot;&gt;为什么数据要写多份&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;单台机器会挂&lt;/li&gt;
  &lt;li&gt;单台机器性能瓶颈&lt;/li&gt;
  &lt;li&gt;架构使然，e.g. 微服务，领域划分&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;写多份为什么有一致性问题&quot;&gt;写多份为什么有一致性问题&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;节点异常 e.g. 机器挂了&lt;/li&gt;
  &lt;li&gt;通信（网络）异常
    &lt;ol&gt;
      &lt;li&gt;消息丢失，e.g. 网络分区，网络设备故障&lt;/li&gt;
      &lt;li&gt;消息乱序&lt;br /&gt;
包级别的乱序可通过网络协议，如TCP解决；&lt;br /&gt;
但消息与消息之间的全局顺序无法保证&lt;/li&gt;
      &lt;li&gt;数据错误，可通过网络协议解决&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;服务异常
    &lt;ol&gt;
      &lt;li&gt;RPC的三态
        &lt;ol&gt;
          &lt;li&gt;成功&lt;/li&gt;
          &lt;li&gt;失败&lt;/li&gt;
          &lt;li&gt;超时（无法确定服务端处理状态）
            &lt;ol&gt;
              &lt;li&gt;客户端发送成功，服务端无响应&lt;/li&gt;
              &lt;li&gt;服务端处理成功，未返回客户端&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;顺序问题&lt;br /&gt;
当有多个客户端，多个服务端，多个存储时，全局的顺序无法保证。&lt;br /&gt;
有可能网络拥堵，有可能进程处理缓慢，有可能硬件处理缓慢等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;理论&quot;&gt;理论&lt;/h2&gt;

&lt;h4 id=&quot;cap定理&quot;&gt;CAP定理&lt;sup id=&quot;fnref:CAP&quot;&gt;&lt;a href=&quot;#fn:CAP&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/CAP.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt;&lt;br /&gt;
Every read receives the most recent write or an error&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Availability&lt;/strong&gt;&lt;br /&gt;
Every request receives a (non-error) response – without guarantee that it contains the most recent write&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Partition tolerance&lt;/strong&gt;&lt;br /&gt;
The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CAP理论指出了C、A、P无法同时满足。&lt;br /&gt;
当出现分区问题时，如果保证了可用性，是无法保证一致性的。因为网络分区的出现，部分节点是不可达的。如果忽略网络分区，一致性和可用性都是可以保证的。&lt;br /&gt;
所以CAP理论更多时候，是在出现网络分区问题时，可用性和一致性的取舍问题。&lt;br /&gt;
选择可用性，必然会导致部分节点无法达到一致；选择一致性，必然要选择部分节点不可提供服务。&lt;/p&gt;

&lt;h4 id=&quot;pacelc-定理&quot;&gt;PACELC 定理&lt;sup id=&quot;fnref:PACELC&quot;&gt;&lt;a href=&quot;#fn:PACELC&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;In theoretical computer science, the PACELC theorem is an extension to the CAP theorem. It states that in case of network partitioning (P) in a distributed computer system, one has to choose between availability (A) and consistency (C) (as per the CAP theorem), but else (E), even when the system is running normally in the absence of partitions, one has to choose between latency (L) and consistency (C).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PACELC定理是CAP定理的延伸，是指在网络分区的情况下，需要在可用性和一致性之间做选择，否则，就在延迟和一致性之间做选择。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2014/01/Transaction-Across-DataCenter.jpg&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
上图来自：Google App Engine的co-founder Ryan Barrett在2009年的google i/o上的演讲《Transaction Across DataCenter》&lt;/p&gt;

&lt;h2 id=&quot;如何实现&quot;&gt;如何实现？&lt;/h2&gt;

&lt;h4 id=&quot;从节点的组织形式上可以分成两类&quot;&gt;从节点的组织形式上可以分成两类：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;中心化副本控制协议 &lt;br /&gt;
通过中心化节点来控制副本的更新来达成一致 e.g. Master-Slave，raft&lt;/li&gt;
  &lt;li&gt;去中心化副本控制协议&lt;br /&gt;
各节点地位相同，通过平等协商的方式来达到一致 e.g. Paxos&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lease机制&quot;&gt;Lease机制&lt;sup id=&quot;fnref:dis&quot;&gt;&lt;a href=&quot;#fn:dis&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;p&gt;Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发 出 lease,则无论接受方是否收到,也无论后续接收方处于何种状态,只要 lease 不过期,颁发者一 定严守承诺;另一方面,接收方在 lease 的有效期内可以使用颁发者的承诺,但一旦 lease 过期,接收方一定不能继续使用颁发者的承诺。&lt;/p&gt;

&lt;p&gt;由于 lease 是一种承诺,具体的承诺内容可以非常宽泛,可以是数据的正确性，如在lease有效期内不会修改数据;也可以是某种权限,例如当需要做并发控制时,同一时刻只给某一个节点颁发 lease,只有持有 lease 的节点才可以修改数据;也可以是某种身份,例如在 primary-secondary架构中,给节点颁发 lease,只有持有 lease 的节点才具有 primary 身份。&lt;/p&gt;

&lt;p&gt;举例说明，GFS 中使用 Lease 确定 Chuck 的 Primary 副本。Lease 由 Master 节点颁发给 primary 副本,持有 Lease 的副本成为 primary 副本。Primary 副本控制该 chuck 的数据更新流量,确定并发更新操作在 chuck 上的执行顺序。GFS 中的 Lease 信息由 Master 在响应各个节点的 HeartBeat 时附带传递 (piggyback)。对于每一个 chuck,其上的并发更新操作的顺序在各个副本上是一致的,首先 master 选择 primary 的顺序,即颁发 Lease 的顺序,在每一任的 primary 任期内,每个 primary 决定并发更 新的顺序,从而更新操作的顺序最终全局一致。当 GFS 的 master 失去某个节点的 HeartBeat 时,只需待该节点上的 primary chuck 的 Lease 超时,就可以为这些 chuck 重新选择 primary 副本并颁发 lease。&lt;/p&gt;

&lt;h4 id=&quot;quorum机制&quot;&gt;Quorum机制&lt;/h4&gt;
&lt;p&gt;在 Quorum 机制下,当某次更新操作 wi 一旦在所有 N 个副本中的 W 个副本上都成功,则就称 该更新操作为“成功提交的更新操作”,称对应的数据为“成功提交的数据”。令 R&amp;gt;N-W,由于更新 操作 wi 仅在 W 个副本上成功,所以在读取数据时,最多需要读取 R 个副本则一定能读到 wi 更新后 的数据 vi 。如果某次更新 wi 在 W 个副本上成功,由于 W+R&amp;gt;N,任意 R 个副本组成的集合一定与 成功的W个副本组成的集合有交集,所以读取R个副本一定能读到wi更新后的数据vi。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/qorum.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;举例说明：&lt;br /&gt;
某系统有 5 个副本,W=3,R=3,最初 5 个副本的数据一致,都是 v1,某次更新操作 w2 在前 3 副本上成功,副本情况变成(v2 v2 v2 v1 v1)。此时,任意 3 个副本组成的集合中一定包括 v2。&lt;/p&gt;

&lt;p&gt;限制 Quorum 参数为 W+R=N+1。由于更新 操作需要在 W 个副本上都成功,更新操作才能成功,所以一旦 N-W+1 个副本异常,更新操作始终 无法在 W 个副本上成功,更新服务不可用。另一方面,一旦 N-R+1 个副本异常,则无法保证一定 可以读到与 W 个副本有交集的副本集合,则读服务的一致性下降。&lt;/p&gt;

&lt;p&gt;N=5,W=2,R=3 时,若 4 个副本异常,更新操作始终无法完成。若 3 个副本异常时, 剩下的两个副本虽然可以提供更新服务,但对于读取者而言,在缺乏某些 magic 机制的,即如果读 取者不知道当前最新已成功提交的版本是什么的时候,仅仅读取 2 个副本并不能保证一定可以读到最新的已提交的数据。&lt;/p&gt;

&lt;p&gt;这里再次强调:&lt;strong&gt;仅仅依赖 quorum 机制是无法保证强一致性的&lt;/strong&gt;。因为仅有 quorum 机制时无法确 定最新已成功提交的版本号,除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数据集群管理,否则很难确定最新成功提交的版本号。&lt;/p&gt;

&lt;h4 id=&quot;paxos&quot;&gt;Paxos&lt;/h4&gt;
&lt;p&gt;去中心化的强一致性协议，具体可以参考wiki &lt;sup id=&quot;fnref:paxos&quot;&gt;&lt;a href=&quot;#fn:paxos&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h4 id=&quot;raft&quot;&gt;Raft&lt;/h4&gt;
&lt;p&gt;通过去中心化的leader选举转化成中心化控制的强一致性协议&lt;/p&gt;

&lt;h4 id=&quot;2pc3pc&quot;&gt;2PC/3PC&lt;/h4&gt;
&lt;p&gt;中心化的强一致性协议&lt;/p&gt;

&lt;h4 id=&quot;master-slave&quot;&gt;Master-Slave&lt;/h4&gt;
&lt;p&gt;中心化的协议，可以根据同步协议来达到不同的一致性级别。举例，mysql的主从同步可以是async、semi-sync、sync来平衡性能和一致性&lt;/p&gt;

&lt;h4 id=&quot;mq&quot;&gt;MQ&lt;/h4&gt;
&lt;p&gt;通过MQ,日志表等方式达到最终一致性&lt;/p&gt;

&lt;h2 id=&quot;引用&quot;&gt;引用&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:consistent&quot;&gt;
      &lt;p&gt;https://en.wikipedia.org/wiki/Consistency_(database_systems) &lt;a href=&quot;#fnref:consistent&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ACID&quot;&gt;
      &lt;p&gt;https://en.wikipedia.org/wiki/ACID &lt;a href=&quot;#fnref:ACID&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Consistent_model&quot;&gt;
      &lt;p&gt;https://en.wikipedia.org/wiki/Consistency_model &lt;a href=&quot;#fnref:Consistent_model&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:CAP&quot;&gt;
      &lt;p&gt;https://en.wikipedia.org/wiki/CAP_theorem &lt;a href=&quot;#fnref:CAP&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:PACELC&quot;&gt;
      &lt;p&gt;https://en.wikipedia.org/wiki/PACELC_theorem &lt;a href=&quot;#fnref:PACELC&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:dis&quot;&gt;
      &lt;p&gt;《分布式系统原理介绍》 刘杰 &lt;a href=&quot;#fnref:dis&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:paxos&quot;&gt;
      &lt;p&gt;https://en.wikipedia.org/wiki/Paxos_(computer_science) &lt;a href=&quot;#fnref:paxos&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 

</feed>
